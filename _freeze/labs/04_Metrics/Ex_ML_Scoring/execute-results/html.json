{
  "hash": "bce0ad887e278374c85a1046079c522a",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Model scoring\"\n---\n\n\n\n# Regression task\n\n## Data\n\nThe data set is the one used in the series on linear regressions.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(readr)\nreal_estate_data <- read.csv(here::here(\"labs/data/real_estate_data.csv\"))\n```\n:::\n\n\nThen we split the data in a training and a test set (0.8/0.2). For this, we use the `createDataPartition` function of the `caret` package.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(caret)\nset.seed(234)\nindex_tr <- createDataPartition(y = real_estate_data$Price, p= 0.8, list = FALSE)\ndf_tr <- real_estate_data[index_tr,]\ndf_te <- real_estate_data[-index_tr,]\n```\n:::\n\n\n## Models\n\nWe will compare a linear regression, a regression tree and a 3-NN (KNN).\n\n::: panel-tabset\n### R\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(rpart)\nest_lm <- lm(Price~TransDate+HouseAge+Dist+\n               NumStores+Lat+Long, data=df_tr)\nest_rt <- rpart(Price~TransDate+HouseAge+Dist+\n                      NumStores+Lat+Long, data=df_tr)\nest_knn <- knnreg(Price~TransDate+HouseAge+Dist+\n                      NumStores+Lat+Long, data=df_tr, k = 3)\n```\n:::\n\n\n### Python\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Load the course python environment as usual with a r code chunks.\nlibrary(reticulate)\nuse_condaenv(\"MLBA\")\n```\n:::\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.python .cell-code}\n# Fit the models: linear regression, regression tree, and KNN\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.tree import DecisionTreeRegressor\nfrom sklearn.neighbors import KNeighborsRegressor\n\n# Define predictors and target variable\npredictors = ['TransDate', 'HouseAge', 'Dist', 'NumStores', 'Lat', 'Long']\ntarget = 'Price'\n\n# Fit models\nest_lm = LinearRegression().fit(r.df_tr[predictors], r.df_tr[target])\nest_rt = DecisionTreeRegressor(random_state=234).fit(r.df_tr[predictors], r.df_tr[target])\nest_knn = KNeighborsRegressor(n_neighbors=3).fit(r.df_tr[predictors], r.df_tr[target])\n```\n:::\n\n\n:::\n\n## R-squared\n\n::: panel-tabset\n### R\nWe now compute the R2 for each model using the a defined function.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nR2 = function(y_predict, y_actual){\n  cor(y_actual,y_predict)^2\n}\n\nR2(predict(est_lm, newdata = df_te), df_te$Price)\nR2(predict(est_rt, newdata = df_te), df_te$Price)\nR2(predict(est_knn, newdata = df_te), df_te$Price)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.6562361\n[1] 0.7719796\n[1] 0.8079045\n```\n\n\n:::\n:::\n\n\nJust for the exercise, we can compute it by hand (square of the correlation)\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncor(predict(est_lm, newdata = df_te), df_te$Price)^2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.6562361\n```\n\n\n:::\n:::\n\n\n### Python\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.python .cell-code}\n# Same thing as the R code\nfrom sklearn.metrics import r2_score\nimport numpy as np\n\n# Only to demonostrate which argument goes where (different from `caret::R2`)\nprint(r2_score(y_true = r.df_te[target], y_pred = est_lm.predict(r.df_te[predictors])))\nprint(r2_score(r.df_te[target], est_rt.predict(r.df_te[predictors])))\nprint(r2_score(r.df_te[target], est_knn.predict(r.df_te[predictors])))\n\n# Computing it by hand gives us the same result as R\nnp.corrcoef(est_lm.predict(r.df_te[predictors]), r.df_te[target])[0][1]**2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n0.6424009640449693\n0.7018428459476751\n0.7971133712172433\nnp.float64(0.6562360670242778)\n```\n\n\n:::\n:::\n\n\nTo understand why the results are different in `R2` from our defined function  in R vs. `sklearn.metrics.r2_score()` in Python, see [this post on stackoverflow](https://stats.stackexchange.com/questions/586821/what-is-the-interpretation-of-the-traditional-r2). If you want to recieve the same results in both, you can try computing the R2 not by correlation but by the formula $1 - \\frac{SSR}{SST}$ where $SSR$ is the sum of squared residuals and $SST$ is the total sum of squares.\n\nAdditionally, please note that the performance of the tree is highly dependent on the seed, so setting a different seed can lead to different results.\n\n:::\n\n## RMSE\n\nNow, we compute the RMSE.\n\n::: panel-tabset\n### R\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nRMSE(predict(est_lm, newdata = df_te), df_te$Price)\nRMSE(predict(est_rt, newdata = df_te), df_te$Price)\nRMSE(predict(est_knn, newdata = df_te), df_te$Price)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 7.498671\n[1] 6.088373\n[1] 5.659951\n```\n\n\n:::\n:::\n\n\nThe formula would be:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsqrt(mean((predict(est_lm, newdata = df_te)-df_te$Price)^2))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 7.498671\n```\n\n\n:::\n:::\n\n\n### Python\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.python .cell-code}\nfrom sklearn.metrics import mean_squared_error, root_mean_squared_error\nimport numpy as np\n\nprint(root_mean_squared_error(r.df_te[target], est_lm.predict(r.df_te[predictors])))\n# alternatively in the older version of `sklearn`, you had to run the code below\n# print(np.sqrt(mean_squared_error(r.df_te[target], est_lm.predict(r.df_te[predictors]))))\nprint(root_mean_squared_error(r.df_te[target], est_rt.predict(r.df_te[predictors])))\nprint(root_mean_squared_error(r.df_te[target], est_knn.predict(r.df_te[predictors])))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n7.498671398473088\n6.84713310132913\n5.648236408450452\n```\n\n\n:::\n:::\n\n\n:::\n\n## MAE\n\nNow, we compute the MAE.\n\n::: panel-tabset\n### R\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nMAE(predict(est_lm, newdata = df_te), df_te$Price)\nMAE(predict(est_rt, newdata = df_te), df_te$Price)\nMAE(predict(est_knn, newdata = df_te), df_te$Price)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5.803592\n[1] 4.599811\n[1] 4.461789\n```\n\n\n:::\n:::\n\nThe formula would be:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmean(abs(predict(est_lm, newdata = df_te)-df_te$Price))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5.803592\n```\n\n\n:::\n:::\n\n\n\n### Python\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.python .cell-code}\n# Compute MAE for each model\nfrom sklearn.metrics import mean_absolute_error\n\nprint(mean_absolute_error(r.df_te[target], est_lm.predict(r.df_te[predictors])))\nprint(mean_absolute_error(r.df_te[target], est_rt.predict(r.df_te[predictors])))\nprint(mean_absolute_error(r.df_te[target], est_knn.predict(r.df_te[predictors])))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n5.80359171132348\n4.726829268292682\n4.4349593495934965\n```\n\n\n:::\n:::\n\n\n:::\n\n## Best model\n\nThese three measures agree on the fact that the regression tree is the best model. To inspect further the predictions, we use scatterplots:\n\n::: panel-tabset\n### R\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npar(mfrow=c(2,2))\nplot(df_te$Price ~ predict(est_lm, newdata = df_te), xlab=\"Prediction\", \n     ylab=\"Observed prices\", main=\"Lin. Reg.\")\nabline(0,1)\nplot(df_te$Price ~ predict(est_rt, newdata = df_te), xlab=\"Prediction\", \n     ylab=\"Observed prices\", main=\"Lin. Reg.\")\nabline(0,1)\nplot(df_te$Price ~ predict(est_knn, newdata = df_te), xlab=\"Prediction\", \n     ylab=\"Observed prices\", main=\"Lin. Reg.\")\nabline(0,1)\npar(mfrow=c(1,1))\n```\n\n::: {.cell-output-display}\n![](Ex_ML_Scoring_files/figure-html/unnamed-chunk-15-1.png){fig-align='center' width=672}\n:::\n:::\n\n\n### Python\n\n::: {.cell layout-align=\"center\"}\n\n```{.python .cell-code}\n# visualize also in Python\nimport matplotlib.pyplot as plt\n\nplt.figure(figsize=(8, 6))\n\nplt.subplot(221);\nplt.scatter(est_lm.predict(r.df_te[predictors]), r.df_te[target], alpha=0.5);\nplt.xlabel(\"Prediction\");\nplt.ylabel(\"Observed prices\");\nplt.title(\"Lin. Reg.\");\nplt.plot(r.df_te[target], r.df_te[target], color='red');\n\nplt.subplot(222);\nplt.scatter(est_rt.predict(r.df_te[predictors]), r.df_te[target], alpha=0.5);\nplt.xlabel(\"Prediction\");\nplt.ylabel(\"Observed prices\");\nplt.title(\"Regression Tree\");\nplt.plot(r.df_te[target], r.df_te[target], color='red');\n\nplt.subplot(223);\nplt.scatter(est_knn.predict(r.df_te[predictors]), r.df_te[target], alpha=0.5);\nplt.xlabel(\"Prediction\");\nplt.ylabel(\"Observed prices\");\nplt.title(\"KNN\");\nplt.plot(r.df_te[target], r.df_te[target], color='red');\n\nplt.tight_layout();\nplt.show()\n```\n\n::: {.cell-output-display}\n![](Ex_ML_Scoring_files/figure-html/unnamed-chunk-16-1.png){fig-align='center' width=768}\n:::\n:::\n\n:::\n\nThe scatterplots are in line with the conclusion that KNN is the best, even though it is not easy to declare from a plot. We can in addition see that the regression tree (RT) has made more error on the larger prices.\n\n# Classification task\n\n## Data\n\nThe data set is the visit data (already used in previous exercises). For simplicity, we turn the outcome (`visits`) into factor. Like before, that are also split into a training and a test set.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nDocVis <- read.csv(here::here(\"labs/data/DocVis.csv\"))\nDocVis$visits <- as.factor(DocVis$visits)\n\nlibrary(caret)\nset.seed(346)\nindex_tr <- createDataPartition(y = DocVis$visits, p= 0.8, list = FALSE)\ndf_tr <- DocVis[index_tr,]\ndf_te <- DocVis[-index_tr,]\n```\n:::\n\n\n## Models\n\nWe will compare a logistic regression, a classification tree (pruned) and a SVM with radial basis (cost and gamma tuned).\n\n:::panel-tabset\n### R\nNote that the *code for tuning the SVM* is provided below in comments because of the time it takes to run. The final parameters have been selected accordingly. Also, the SVM fit includes the argument `probability=TRUE` to allow the calculations of predicted probabilities later.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(e1071)\nlibrary(adabag)\n\n## Logistic regression\nDoc_lr <- glm(visits~., data=df_tr, family=\"binomial\")\nDoc_lr <- step(Doc_lr)\n\n## Classification tree \nDoc_ct <- autoprune(visits~., data=df_tr)\n\n## SVM radial basis\n# grid_radial <- expand.grid(sigma = c(0.0001, 0.001, 0.01, 0.1),\n#                           C = c(0.1, 1, 10, 100, 1000))\n# trctrl <- trainControl(method = \"cv\", number=10)\n# set.seed(143)\n# Doc_svm <- train(visits ~., data = df_tr, method = \"svmRadial\",\n#                          trControl=trctrl,\n#                          tuneGrid = grid_radial)\nDoc_svm <- svm(visits~., data=df_tr, gamma=0.001, cost=1000, probability=TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nStart:  AIC=3652.59\nvisits ~ gender + age + income + illness + reduced + health + \n    private + freepoor + freerepat + nchronic + lchronic\n\n            Df Deviance    AIC\n- nchronic   1   3629.0 3651.0\n- income     1   3630.4 3652.4\n<none>           3628.6 3652.6\n- lchronic   1   3632.0 3654.0\n- freerepat  1   3633.3 3655.3\n- private    1   3633.9 3655.9\n- age        1   3635.0 3657.0\n- gender     1   3636.8 3658.8\n- freepoor   1   3637.1 3659.1\n- health     1   3637.7 3659.7\n- illness    1   3703.2 3725.2\n- reduced    1   3779.4 3801.4\n\nStep:  AIC=3651.02\nvisits ~ gender + age + income + illness + reduced + health + \n    private + freepoor + freerepat + lchronic\n\n            Df Deviance    AIC\n- income     1   3630.8 3650.8\n<none>           3629.0 3651.0\n- lchronic   1   3632.1 3652.1\n- freerepat  1   3633.8 3653.8\n- private    1   3634.5 3654.5\n- age        1   3636.6 3656.6\n- freepoor   1   3637.4 3657.4\n- gender     1   3637.5 3657.5\n- health     1   3638.2 3658.2\n- illness    1   3712.9 3732.9\n- reduced    1   3779.9 3799.9\n\nStep:  AIC=3650.8\nvisits ~ gender + age + illness + reduced + health + private + \n    freepoor + freerepat + lchronic\n\n            Df Deviance    AIC\n<none>           3630.8 3650.8\n- lchronic   1   3633.8 3651.8\n- private    1   3635.6 3653.6\n- freerepat  1   3636.8 3654.8\n- freepoor   1   3638.2 3656.2\n- age        1   3639.4 3657.4\n- health     1   3640.4 3658.4\n- gender     1   3641.4 3659.4\n- illness    1   3715.8 3733.8\n- reduced    1   3781.1 3799.1\n```\n\n\n:::\n:::\n\n\n### Python\n\n::: {.cell layout-align=\"center\"}\n\n```{.python .cell-code}\nimport pandas as pd\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.tree import DecisionTreeClassifier\nfrom sklearn.svm import SVC\n\n# We first put the data in a nice format by one-hot encoding the categorical variables\nX_train = pd.get_dummies(r.df_tr.drop('visits', axis=1))\ny_train = r.df_tr['visits']\nX_test = pd.get_dummies(r.df_te.drop('visits', axis=1))\ny_test = r.df_te['visits']\n\n## Logistic regression\ndoc_lr = LogisticRegression()\ndoc_lr.fit(X_train, y_train);\n\n## Classification tree\ndoc_ct = DecisionTreeClassifier(random_state=123)\ndoc_ct.fit(X_train, y_train);\n\n## SVM radial basis\ndoc_svm = SVC(kernel='rbf', gamma=0.001, C=1000, probability=True, random_state=123)\ndoc_svm.fit(X_train, y_train);\n```\n:::\n\n:::\n\n## Predictions\n\nWe now compute the predicted probabilities and the predictions of all the models.\n\n::: panel-tabset\n## R\nNote that, for SVM, we need to extract the *attribute* \"probabilities\" from the predicted object. This can be done with the `attr` function.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n## Logistic regression\nDoc_lr_prob <- predict(Doc_lr, newdata=df_te, type=\"response\")\nDoc_lr_pred <- ifelse(Doc_lr_prob>0.5,\"Yes\",\"No\")\n\n## Classification tree \nDoc_ct_prob <- predict(Doc_ct, newdata=df_te, type=\"prob\")\nDoc_ct_pred <- predict(Doc_ct, newdata=df_te, type=\"class\")\n\n## SVM radial basis\nlibrary(dplyr)\nDoc_svm_prob <- predict(Doc_svm, newdata=df_te, probability=TRUE) %>% attr(\"probabilities\")\nDoc_svm_pred <- predict(Doc_svm, newdata=df_te, type=\"class\")\n```\n:::\n\n\n## Python\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.python .cell-code}\n## Logistic regression\n## the second column represents the `no` values, to make sure of that, you can run `doc_lr.classes_`\ndoc_lr_prob = doc_lr.predict_proba(X_test)[:,1]\ndoc_lr_pred = np.where(doc_lr_prob>0.5, \"Yes\", \"No\")\n\n## Classification tree\ndoc_ct_prob = doc_ct.predict_proba(X_test)[:,1]\ndoc_ct_pred = doc_ct.predict(X_test)\n\n## SVM radial basis\ndoc_svm_prob = doc_svm.predict_proba(X_test)[:,1]\ndoc_svm_pred = doc_svm.predict(X_test)\n```\n:::\n\n:::\n\n## Confusion matrices & prediction-based measures\n\n::: panel-tabset\n### R\nThe `confusionMatrix` function provides all the accuracy measures that we want.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nconfusionMatrix(data=as.factor(Doc_lr_pred), reference = df_te$visits)\nconfusionMatrix(data=as.factor(Doc_ct_pred), reference = df_te$visits)\nconfusionMatrix(data=as.factor(Doc_svm_pred), reference = df_te$visits)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nConfusion Matrix and Statistics\n\n          Reference\nPrediction  No Yes\n       No  809 179\n       Yes  19  30\n                                          \n               Accuracy : 0.8091          \n                 95% CI : (0.7838, 0.8326)\n    No Information Rate : 0.7985          \n    P-Value [Acc > NIR] : 0.2089          \n                                          \n                  Kappa : 0.1689          \n                                          \n Mcnemar's Test P-Value : <2e-16          \n                                          \n            Sensitivity : 0.9771          \n            Specificity : 0.1435          \n         Pos Pred Value : 0.8188          \n         Neg Pred Value : 0.6122          \n             Prevalence : 0.7985          \n         Detection Rate : 0.7801          \n   Detection Prevalence : 0.9527          \n      Balanced Accuracy : 0.5603          \n                                          \n       'Positive' Class : No              \n                                          \nConfusion Matrix and Statistics\n\n          Reference\nPrediction  No Yes\n       No  791 149\n       Yes  37  60\n                                          \n               Accuracy : 0.8206          \n                 95% CI : (0.7959, 0.8435)\n    No Information Rate : 0.7985          \n    P-Value [Acc > NIR] : 0.03934         \n                                          \n                  Kappa : 0.3031          \n                                          \n Mcnemar's Test P-Value : 3.988e-16       \n                                          \n            Sensitivity : 0.9553          \n            Specificity : 0.2871          \n         Pos Pred Value : 0.8415          \n         Neg Pred Value : 0.6186          \n             Prevalence : 0.7985          \n         Detection Rate : 0.7628          \n   Detection Prevalence : 0.9065          \n      Balanced Accuracy : 0.6212          \n                                          \n       'Positive' Class : No              \n                                          \nConfusion Matrix and Statistics\n\n          Reference\nPrediction  No Yes\n       No  802 159\n       Yes  26  50\n                                          \n               Accuracy : 0.8216          \n                 95% CI : (0.7969, 0.8444)\n    No Information Rate : 0.7985          \n    P-Value [Acc > NIR] : 0.03302         \n                                          \n                  Kappa : 0.2727          \n                                          \n Mcnemar's Test P-Value : < 2e-16         \n                                          \n            Sensitivity : 0.9686          \n            Specificity : 0.2392          \n         Pos Pred Value : 0.8345          \n         Neg Pred Value : 0.6579          \n             Prevalence : 0.7985          \n         Detection Rate : 0.7734          \n   Detection Prevalence : 0.9267          \n      Balanced Accuracy : 0.6039          \n                                          \n       'Positive' Class : No              \n                                          \n```\n\n\n:::\n:::\n\n\n### Python\n\n::: {.cell layout-align=\"center\"}\n\n```{.python .cell-code}\nfrom sklearn.metrics import confusion_matrix, accuracy_score, balanced_accuracy_score, cohen_kappa_score\n\n## Logistic regression\nprint(confusion_matrix(y_test, doc_lr_pred))\nprint(f\"Accuracy: {accuracy_score(y_test, doc_lr_pred):.3f}\")\nprint(f\"Kappa: {cohen_kappa_score(y_test, doc_lr_pred):.3f}\")\nprint(f\"Balanced accuracy: {balanced_accuracy_score(y_test, doc_lr_pred):.3f}\")\n\n## Classification tree\nprint(confusion_matrix(y_test, doc_ct_pred))\nprint(f\"Accuracy: {accuracy_score(y_test, doc_ct_pred):.3f}\")\nprint(f\"Kappa: {cohen_kappa_score(y_test, doc_ct_pred):.3f}\")\nprint(f\"Balanced accuracy: {balanced_accuracy_score(y_test, doc_ct_pred):.3f}\")\n\n## SVM radial basis\nprint(confusion_matrix(y_test, doc_svm_pred))\nprint(f\"Accuracy: {accuracy_score(y_test, doc_svm_pred):.3f}\")\nprint(f\"Kappa: {cohen_kappa_score(y_test, doc_svm_pred):.3f}\")\nprint(f\"Balanced accuracy: {balanced_accuracy_score(y_test, doc_svm_pred):.3f}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[809  19]\n [179  30]]\nAccuracy: 0.809\nKappa: 0.169\nBalanced accuracy: 0.560\n[[724 104]\n [145  64]]\nAccuracy: 0.760\nKappa: 0.195\nBalanced accuracy: 0.590\n[[808  20]\n [169  40]]\nAccuracy: 0.818\nKappa: 0.228\nBalanced accuracy: 0.584\n```\n\n\n:::\n:::\n\nDifferent results for the tree and CSV due to randomness, but even with that, SVM remains the best model in terms of accuracy.\n\n:::\n\nThe conclusion may be different from one measure to another\n\n-   Accuracy: the SVM reaches the highest accuracy\n-   Kappa: the CT is the highest.\n-   Balanced accuracy: the CT is the highest.\n-   etc.\n\nLooking at the confusion matrix, we see that the data is highly unbalanced (many more \"No\" than \"Yes\"). Therefore, measures like balanced accuracy and kappa are interesting because they take this characteristics into account. This shows that the CT is probably better than the SVM because it reaches a better balance between predicting \"Yes\" and \"No\".\n\nBy looking at the sensitivity and specificity ([!! here the positive class is \"No\"]{.underline}), we see that the best model to recover the \"No\" is the logistic regression (largest sensitivity) and the best model to recover the \"Yes\" is the classification tree (largest specificity).\n\n## Probability-based measures\n\n::: panel-tabset\n### R\nTo compute the AUC (area under the ROC curve) we can use the `caret::twoClassSummary` function. The use of this function can be tricky. Its argument should be a data frame with columns (names are fixed):\n\n-   \"obs\": the observed classes\n-   \"pred\": the predicted classes\n-   two columns with names being the levels of the classes, here \"Yes\" and \"No\", containing the predicted probabilities.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndf_pred_lr <- data.frame(obs=df_te$visits,\n                         Yes=Doc_lr_prob,\n                         No=1-Doc_lr_prob,\n                         pred=as.factor(Doc_lr_pred))\nhead(df_pred_lr)\n\ndf_pred_ct <- data.frame(obs=df_te$visits,\n                         Doc_ct_prob,\n                         pred=as.factor(Doc_ct_pred))\nhead(df_pred_ct)\ndf_pred_svm <- data.frame(obs=df_te$visits,\n                          Doc_svm_prob,\n                          pred=as.factor(Doc_svm_pred))\nhead(df_pred_svm)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   obs        Yes        No pred\n6  Yes 0.43567107 0.5643289   No\n11 Yes 0.08350891 0.9164911   No\n12 Yes 0.16600203 0.8339980   No\n13 Yes 0.55658181 0.4434182  Yes\n14 Yes 0.47463795 0.5253620   No\n15 Yes 0.19414583 0.8058542   No\n   obs        No       Yes pred\n6  Yes 0.8437079 0.1562921   No\n11 Yes 0.8437079 0.1562921   No\n12 Yes 0.8437079 0.1562921   No\n13 Yes 0.3785311 0.6214689  Yes\n14 Yes 0.3785311 0.6214689  Yes\n15 Yes 0.8437079 0.1562921   No\n   obs       Yes        No pred\n6  Yes 0.2263059 0.7736941   No\n11 Yes 0.1619207 0.8380793   No\n12 Yes 0.1622321 0.8377679   No\n13 Yes 0.7072647 0.2927353  Yes\n14 Yes 0.6285501 0.3714499  Yes\n15 Yes 0.2273475 0.7726525   No\n```\n\n\n:::\n:::\n\n\nThen we pass these objects to the function, and levels of the classes to be predicted (for the function to be able to recover them in the data frame). The function compute the AUC by default (under the name ROC_.. not very wise) as well as sensitivity and specificity (that we already have).\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntwoClassSummary(df_pred_lr, lev = levels(df_pred_lr$obs))\ntwoClassSummary(df_pred_ct, lev = levels(df_pred_lr$obs))\ntwoClassSummary(df_pred_svm, lev = levels(df_pred_lr$obs))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      ROC      Sens      Spec \n0.7320170 0.9770531 0.1435407 \n      ROC      Sens      Spec \n0.6261673 0.9553140 0.2870813 \n      ROC      Sens      Spec \n0.7189631 0.9685990 0.2392344 \n```\n\n\n:::\n:::\n\n\nThis brings us another view: the logistic regression has the highest AUC. This shows that varying the prediction threshold provides a good potential of improving the specificity and the sensitivity (in fine, the balanced accuracy).\n\nNow we compute the entropy using the `mnLogLoss` function (entropy is also called *log-loss*).\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmnLogLoss(df_pred_lr, lev = levels(df_pred_lr$obs))\nmnLogLoss(df_pred_ct, lev = levels(df_pred_lr$obs))\nmnLogLoss(df_pred_svm, lev = levels(df_pred_lr$obs))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  logLoss \n0.4492389 \n  logLoss \n0.4596595 \n  logLoss \n0.4545877 \n```\n\n\n:::\n:::\n\n\nHere again, the entropy selects the logistic regression as the best model, though close to classification tree and SVM.\n\n### Python\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.python .cell-code}\nfrom sklearn.metrics import roc_auc_score, roc_curve\n\n## Logistic regression\nprint(f\"AUC: {roc_auc_score(y_test, doc_lr_prob):.3f}\")\n\n## Classification tree\nprint(f\"AUC: {roc_auc_score(y_test, doc_ct_prob):.3f}\")\n\n## SVM radial basis\nprint(f\"AUC: {roc_auc_score(y_test, doc_svm_prob):.3f}\")\n\n# Now we compute the entropy using the `log_loss` function (entropy is also called *log-loss*).\n\nfrom sklearn.metrics import log_loss\n\n## Logistic regression\nprint(f\"Log-loss: {log_loss(y_test, doc_lr_prob):.3f}\")\n\n## Classification tree\nprint(f\"Log-loss: {log_loss(y_test, doc_ct_prob):.3f}\")\n\n## SVM radial basis\nprint(f\"Log-loss: {log_loss(y_test, doc_svm_prob):.3f}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nAUC: 0.729\nAUC: 0.602\nAUC: 0.732\nLog-loss: 0.450\nLog-loss: 7.688\nLog-loss: 0.462\n```\n\n\n:::\n:::\n\n\n:::\n\n## ROC curve & prob threshold tuning\n\n::: panel-tabset\n### R\nTo go deeper in the analysis, we now produce the ROC curve of each model using the `roc` function of the `proc` package.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(pROC)\nROC_lr <- roc(obs ~ Yes, data=df_pred_lr)\nROC_ct <- roc(obs ~ Yes, data=df_pred_ct)\nROC_svm <- roc(obs ~ Yes, data=df_pred_svm)\n\nplot(ROC_lr, print.thres=\"best\")\nplot(ROC_ct, print.thres=\"best\", add=TRUE)\nplot(ROC_svm, print.thres=\"best\", add=TRUE)\n```\n\n::: {.cell-output-display}\n![](Ex_ML_Scoring_files/figure-html/unnamed-chunk-28-1.png){fig-align='center' width=672}\n:::\n:::\n\n\nThe plotting function provides an \"optimal\" threshold that reaches the best trade-off between sensitivity and specificity (according to some criterion). We see that there is room to improve this trade-off.\n\nNow, to tune this threshold, we need to do it *on the training set* to avoid overfitting. To do this, we just repeat the previous calculations (predictions) on the training set. To simplify, we only do this on the logistic regression (note that you can try on the other models; you may find that logistic regression is the best one).\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nDoc_lr_prob_tr <- predict(Doc_lr, newdata=df_tr, type=\"response\")\ndf_pred_lr_tr <- data.frame(obs=df_tr$visits,\n                            Yes=Doc_lr_prob_tr)\nROC_lr_tr <- roc(obs ~ Yes, data=df_pred_lr_tr)\nplot(ROC_lr_tr, print.thres=\"best\")\n```\n\n::: {.cell-output-display}\n![](Ex_ML_Scoring_files/figure-html/unnamed-chunk-29-1.png){fig-align='center' width=672}\n:::\n:::\n\n\nThe best threshold is 0.193. Now let us compute the confusion table with this threshold.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nDoc_lr_pred_opt <- ifelse(Doc_lr_prob>0.193,\"Yes\",\"No\")\nconfusionMatrix(data=as.factor(Doc_lr_pred_opt), reference = df_te$visits)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nConfusion Matrix and Statistics\n\n          Reference\nPrediction  No Yes\n       No  595  79\n       Yes 233 130\n                                          \n               Accuracy : 0.6991          \n                 95% CI : (0.6702, 0.7269)\n    No Information Rate : 0.7985          \n    P-Value [Acc > NIR] : 1               \n                                          \n                  Kappa : 0.2671          \n                                          \n Mcnemar's Test P-Value : <2e-16          \n                                          \n            Sensitivity : 0.7186          \n            Specificity : 0.6220          \n         Pos Pred Value : 0.8828          \n         Neg Pred Value : 0.3581          \n             Prevalence : 0.7985          \n         Detection Rate : 0.5738          \n   Detection Prevalence : 0.6500          \n      Balanced Accuracy : 0.6703          \n                                          \n       'Positive' Class : No              \n                                          \n```\n\n\n:::\n:::\n\n\nWe now have a model with an accuracy of circa $70\\%$ but with a balanced accuracy of $67\\%$. Far from perfect, this is still an interesting improvement compare to the CT $62\\%$. The specificity and sensitivity are now respectively $62\\%$ and $72\\%$. The specificity in particular made a huge improvement (from around $29\\%$ at best - by CT - to $62\\%$ - by log. reg).\n\nIf the aim is to predict both \"Yes\" and \"No\", this last model (log. reg. with tuned threshold) is the best one to use.\n\n### Python\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.python .cell-code}\n## Logistic regression\n## We need to turn back our results into binary values to be plotted\ndoc_lr_prob_dict = {'Yes': 1, 'No': 0}\ny_test_binary = np.array([doc_lr_prob_dict[x] for x in y_test])\nfpr_lr, tpr_lr, thresholds_lr = roc_curve(y_test_binary, doc_lr_prob)\nplt.plot(fpr_lr, tpr_lr, label=\"Logistic Regression\");\n\n## Classification tree\ndoc_ct_prob_dict = {'Yes': 1, 'No': 0}\ny_test_binary = np.array([doc_ct_prob_dict[x] for x in y_test])\nfpr_ct, tpr_ct, thresholds_ct = roc_curve(y_test_binary, doc_ct_prob)\nplt.plot(fpr_ct, tpr_ct, label=\"Classification Tree\");\n\n## SVM radial basis\ndoc_svm_prob_dict = {'Yes': 1, 'No': 0}\ny_test_binary = np.array([doc_svm_prob_dict[x] for x in y_test])\nfpr_svm, tpr_svm, thresholds_svm = roc_curve(y_test_binary, doc_svm_prob)\n\n# Clear the last plot (if any)\n# plt.clf()\n\nplt.plot(fpr_svm, tpr_svm, label=\"SVM Radial Basis\");\n# Plot the ROC curve\nplt.plot([0, 1], [0, 1], 'k--', label=\"Random Classifier\");\nplt.xlabel(\"False Positive Rate\");\nplt.ylabel(\"True Positive Rate\");\nplt.title(\"ROC Curve\");\nplt.legend();\nplt.show()\n```\n\n::: {.cell-output-display}\n![](Ex_ML_Scoring_files/figure-html/unnamed-chunk-31-1.png){fig-align='center' width=672}\n:::\n:::\n\n\nWe can then plot the results in the similar way to R:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.python .cell-code}\ndoc_lr_prob_tr = doc_lr.predict_proba(X_train)[:,1]\ndoc_lr_prob_tr_dict = {'Yes': 1, 'No': 0}\ny_train_binary = np.array([doc_lr_prob_tr_dict[x] for x in y_train])\nfpr_lr_tr, tpr_lr_tr, thresholds_lr_tr = roc_curve(y_train_binary, doc_lr_prob_tr)\noptimal_idx = np.argmax(tpr_lr_tr - fpr_lr_tr)\noptimal_threshold = thresholds_lr_tr[optimal_idx]\nprint(f\"Optimal threshold: {optimal_threshold:.3f}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nOptimal threshold: 0.188\n```\n\n\n:::\n:::\n\n\nFinally, we print the confusion matrix again:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.python .cell-code}\ndoc_lr_pred_opt = np.where(doc_lr_prob > optimal_threshold, \"Yes\", \"No\")\nprint(confusion_matrix(y_test, doc_lr_pred_opt))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[578 250]\n [ 80 129]]\n```\n\n\n:::\n:::\n\nThe logistic regression produced with R was better.\n\n:::\n\n# Your turn\n\n## Classification\n\nRepeat the analysis on the German credit data. Put several models in competition. Tune them and try to optimize their threshold. Select the best one and analyze its performance.\n\n## Regression\n\nRepeat the analysis on the nursing cost data. Put several models in competition. Tune them and select the best one. Analyze its performance using a scatterplot.\n",
    "supporting": [
      "Ex_ML_Scoring_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}