{
  "hash": "58e243b7abe3f18056bf0ce89b170830",
  "result": {
    "engine": "knitr",
    "markdown": "How can I render the following?---\ntitle: \"Model scoring\"\n---\n\n\n\n# Regression task\n\n## Data\n\nThe data set is the one used in the series on linear regressions.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(readr)\nreal_estate_data <- read.csv(here::here(\"labs/data/real_estate_data.csv\"))\n```\n:::\n\n\nThen we split the data in a training and a test set (0.8/0.2). For this, we use the `createDataPartition` function of the `caret` package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(caret)\nset.seed(234)\nindex_tr <- createDataPartition(y = real_estate_data$Price, p= 0.8, list = FALSE)\ndf_tr <- real_estate_data[index_tr,]\ndf_te <- real_estate_data[-index_tr,]\n```\n:::\n\n\n## Models\n\nWe will compare a linear regression, a regression tree and a 3-NN (KNN).\n\n::: panel-tabset\n### R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(rpart)\nest_lm <- lm(Price~TransDate+HouseAge+Dist+\n               NumStores+Lat+Long, data=df_tr)\nest_rt <- rpart(Price~TransDate+HouseAge+Dist+\n                      NumStores+Lat+Long, data=df_tr)\nest_knn <- knnreg(Price~TransDate+HouseAge+Dist+\n                      NumStores+Lat+Long, data=df_tr, k = 3)\n```\n:::\n\n\n### Python\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load the course python environment as usual with a r code chunks.\nlibrary(reticulate)\nuse_condaenv(\"MLBA\")\n```\n:::\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Fit the models: linear regression, regression tree, and KNN\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.tree import DecisionTreeRegressor\nfrom sklearn.neighbors import KNeighborsRegressor\n\n# Define predictors and target variable\npredictors = ['TransDate', 'HouseAge', 'Dist', 'NumStores', 'Lat', 'Long']\ntarget = 'Price'\n\n# Fit models\nest_lm = LinearRegression().fit(r.df_tr[predictors], r.df_tr[target])\nest_rt = DecisionTreeRegressor(random_state=234).fit(r.df_tr[predictors], r.df_tr[target])\nest_knn = KNeighborsRegressor(n_neighbors=3).fit(r.df_tr[predictors], r.df_tr[target])\n```\n:::\n\n\n:::\n\n## R-squared\n\n::: panel-tabset\n### R\nWe now compute the R2 for each model using the a defined function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nR2 = function(y_predict, y_actual){\n  cor(y_actual,y_predict)^2\n}\n\nR2(predict(est_lm, newdata = df_te), df_te$Price)\nR2(predict(est_rt, newdata = df_te), df_te$Price)\nR2(predict(est_knn, newdata = df_te), df_te$Price)\n```\n:::\n\n\nJust for the exercise, we can compute it by hand (square of the correlation)\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncor(predict(est_lm, newdata = df_te), df_te$Price)^2\n```\n:::\n\n\n### Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Same thing as the R code\nfrom sklearn.metrics import r2_score\nimport numpy as np\n\n# Only to demonostrate which argument goes where (different from `caret::R2`)\nprint(r2_score(y_true = r.df_te[target], y_pred = est_lm.predict(r.df_te[predictors])))\nprint(r2_score(r.df_te[target], est_rt.predict(r.df_te[predictors])))\nprint(r2_score(r.df_te[target], est_knn.predict(r.df_te[predictors])))\n\n# Computing it by hand gives us the same result as R\nnp.corrcoef(est_lm.predict(r.df_te[predictors]), r.df_te[target])[0][1]**2\n```\n:::\n\n\nTo understand why the results are different in `R2` from our defined function  in R vs. `sklearn.metrics.r2_score()` in Python, see [this post on stackoverflow](https://stats.stackexchange.com/questions/586821/what-is-the-interpretation-of-the-traditional-r2). If you want to recieve the same results in both, you can try computing the R2 not by correlation but by the formula $1 - \\frac{SSR}{SST}$ where $SSR$ is the sum of squared residuals and $SST$ is the total sum of squares.\n\nAdditionally, please note that the performance of the tree is highly dependent on the seed, so setting a different seed can lead to different results.\n\n:::\n\n## RMSE\n\nNow, we compute the RMSE.\n\n::: panel-tabset\n### R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nRMSE(predict(est_lm, newdata = df_te), df_te$Price)\nRMSE(predict(est_rt, newdata = df_te), df_te$Price)\nRMSE(predict(est_knn, newdata = df_te), df_te$Price)\n```\n:::\n\n\nThe formula would be:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt(mean((predict(est_lm, newdata = df_te)-df_te$Price)^2))\n```\n:::\n\n\n### Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\nfrom sklearn.metrics import mean_squared_error, root_mean_squared_error\nimport numpy as np\n\nprint(root_mean_squared_error(r.df_te[target], est_lm.predict(r.df_te[predictors])))\n# alternatively in the older version of `sklearn`, you had to run the code below\n# print(np.sqrt(mean_squared_error(r.df_te[target], est_lm.predict(r.df_te[predictors]))))\nprint(root_mean_squared_error(r.df_te[target], est_rt.predict(r.df_te[predictors])))\nprint(root_mean_squared_error(r.df_te[target], est_knn.predict(r.df_te[predictors])))\n```\n:::\n\n\n:::\n\n## MAE\n\nNow, we compute the MAE.\n\n::: panel-tabset\n### R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nMAE(predict(est_lm, newdata = df_te), df_te$Price)\nMAE(predict(est_rt, newdata = df_te), df_te$Price)\nMAE(predict(est_knn, newdata = df_te), df_te$Price)\n```\n:::\n\nThe formula would be:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(abs(predict(est_lm, newdata = df_te)-df_te$Price))\n```\n:::\n\n\n\n### Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Compute MAE for each model\nfrom sklearn.metrics import mean_absolute_error\n\nprint(mean_absolute_error(r.df_te[target], est_lm.predict(r.df_te[predictors])))\nprint(mean_absolute_error(r.df_te[target], est_rt.predict(r.df_te[predictors])))\nprint(mean_absolute_error(r.df_te[target], est_knn.predict(r.df_te[predictors])))\n```\n:::\n\n\n:::\n\n## Best model\n\nThese three measures agree on the fact that the regression tree is the best model. To inspect further the predictions, we use scatterplots:\n\n::: panel-tabset\n### R\n\n\n::: {.cell}\n\n```{.r .cell-code}\npar(mfrow=c(2,2))\nplot(df_te$Price ~ predict(est_lm, newdata = df_te), xlab=\"Prediction\", \n     ylab=\"Observed prices\", main=\"Lin. Reg.\")\nabline(0,1)\nplot(df_te$Price ~ predict(est_rt, newdata = df_te), xlab=\"Prediction\", \n     ylab=\"Observed prices\", main=\"Lin. Reg.\")\nabline(0,1)\nplot(df_te$Price ~ predict(est_knn, newdata = df_te), xlab=\"Prediction\", \n     ylab=\"Observed prices\", main=\"Lin. Reg.\")\nabline(0,1)\npar(mfrow=c(1,1))\n```\n:::\n\n\n### Python\n\n::: {.cell}\n\n```{.python .cell-code}\n# visualize also in Python\nimport matplotlib.pyplot as plt\n\nplt.figure(figsize=(8, 6))\n\nplt.subplot(221)\nplt.scatter(est_lm.predict(r.df_te[predictors]), r.df_te[target], alpha=0.5)\nplt.xlabel(\"Prediction\")\nplt.ylabel(\"Observed prices\")\nplt.title(\"Lin. Reg.\")\nplt.plot(r.df_te[target], r.df_te[target], color='red')\n\nplt.subplot(222)\nplt.scatter(est_rt.predict(r.df_te[predictors]), r.df_te[target], alpha=0.5)\nplt.xlabel(\"Prediction\")\nplt.ylabel(\"Observed prices\")\nplt.title(\"Regression Tree\")\nplt.plot(r.df_te[target], r.df_te[target], color='red')\n\nplt.subplot(223)\nplt.scatter(est_knn.predict(r.df_te[predictors]), r.df_te[target], alpha=0.5)\nplt.xlabel(\"Prediction\")\nplt.ylabel(\"Observed prices\")\nplt.title(\"KNN\")\nplt.plot(r.df_te[target], r.df_te[target], color='red')\n\nplt.tight_layout()\nplt.show()\n```\n:::\n\n:::\n\nThe scatterplots are in line with the conclusion that KNN is the best, even though it is not easy to declare from a plot. We can in addition see that the regression tree (RT) has made more error on the larger prices.\n\n# Classification task\n\n## Data\n\nThe data set is the visit data (already used in previous exercises). For simplicity, we turn the outcome (`visits`) into factor. Like before, that are also split into a training and a test set.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDocVis <- read.csv(here::here(\"labs/data/DocVis.csv\"))\nDocVis$visits <- as.factor(DocVis$visits)\n\nlibrary(caret)\nset.seed(346)\nindex_tr <- createDataPartition(y = DocVis$visits, p= 0.8, list = FALSE)\ndf_tr <- DocVis[index_tr,]\ndf_te <- DocVis[-index_tr,]\n```\n:::\n\n\n## Models\n\nWe will compare a logistic regression, a classification tree (pruned) and a SVM with radial basis (cost and gamma tuned).\n\n:::panel-tabset\n### R\nNote that the *code for tuning the SVM* is provided below in comments because of the time it takes to run. The final parameters have been selected accordingly. Also, the SVM fit includes the argument `probability=TRUE` to allow the calculations of predicted probabilities later.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(e1071)\nlibrary(adabag)\n\n## Logistic regression\nDoc_lr <- glm(visits~., data=df_tr, family=\"binomial\")\nDoc_lr <- step(Doc_lr)\n\n## Classification tree \nDoc_ct <- autoprune(visits~., data=df_tr)\n\n## SVM radial basis\n# grid_radial <- expand.grid(sigma = c(0.0001, 0.001, 0.01, 0.1),\n#                           C = c(0.1, 1, 10, 100, 1000))\n# trctrl <- trainControl(method = \"cv\", number=10)\n# set.seed(143)\n# Doc_svm <- train(visits ~., data = df_tr, method = \"svmRadial\",\n#                          trControl=trctrl,\n#                          tuneGrid = grid_radial)\nDoc_svm <- svm(visits~., data=df_tr, gamma=0.001, cost=1000, probability=TRUE)\n```\n:::\n\n\n### Python\n\n::: {.cell}\n\n```{.python .cell-code}\nimport pandas as pd\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.tree import DecisionTreeClassifier\nfrom sklearn.svm import SVC\n\n# We first put the data in a nice format by one-hot encoding the categorical variables\nX_train = pd.get_dummies(r.df_tr.drop('visits', axis=1))\ny_train = r.df_tr['visits']\nX_test = pd.get_dummies(r.df_te.drop('visits', axis=1))\ny_test = r.df_te['visits']\n\n## Logistic regression\ndoc_lr = LogisticRegression()\ndoc_lr.fit(X_train, y_train)\n\n## Classification tree\ndoc_ct = DecisionTreeClassifier(random_state=123)\ndoc_ct.fit(X_train, y_train)\n\n## SVM radial basis\ndoc_svm = SVC(kernel='rbf', gamma=0.001, C=1000, probability=True, random_state=123)\ndoc_svm.fit(X_train, y_train)\n```\n:::\n\n:::\n\n## Predictions\n\nWe now compute the predicted probabilities and the predictions of all the models.\n\n::: panel-tabset\n## R\nNote that, for SVM, we need to extract the *attribute* \"probabilities\" from the predicted object. This can be done with the `attr` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Logistic regression\nDoc_lr_prob <- predict(Doc_lr, newdata=df_te, type=\"response\")\nDoc_lr_pred <- ifelse(Doc_lr_prob>0.5,\"Yes\",\"No\")\n\n## Classification tree \nDoc_ct_prob <- predict(Doc_ct, newdata=df_te, type=\"prob\")\nDoc_ct_pred <- predict(Doc_ct, newdata=df_te, type=\"class\")\n\n## SVM radial basis\nlibrary(dplyr)\nDoc_svm_prob <- predict(Doc_svm, newdata=df_te, probability=TRUE) %>% attr(\"probabilities\")\nDoc_svm_pred <- predict(Doc_svm, newdata=df_te, type=\"class\")\n```\n:::\n\n\n## Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\n## Logistic regression\n## the second column represents the `no` values, to make sure of that, you can run `doc_lr.classes_`\ndoc_lr_prob = doc_lr.predict_proba(X_test)[:,1]\ndoc_lr_pred = np.where(doc_lr_prob>0.5, \"Yes\", \"No\")\n\n## Classification tree\ndoc_ct_prob = doc_ct.predict_proba(X_test)[:,1]\ndoc_ct_pred = doc_ct.predict(X_test)\n\n## SVM radial basis\ndoc_svm_prob = doc_svm.predict_proba(X_test)[:,1]\ndoc_svm_pred = doc_svm.predict(X_test)\n```\n:::\n\n:::\n\n## Confusion matrices & prediction-based measures\n\n::: panel-tabset\n### R\nThe `confusionMatrix` function provides all the accuracy measures that we want.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nconfusionMatrix(data=as.factor(Doc_lr_pred), reference = df_te$visits)\nconfusionMatrix(data=as.factor(Doc_ct_pred), reference = df_te$visits)\nconfusionMatrix(data=as.factor(Doc_svm_pred), reference = df_te$visits)\n```\n:::\n\n\n### Python\n\n::: {.cell}\n\n```{.python .cell-code}\nfrom sklearn.metrics import confusion_matrix, accuracy_score, balanced_accuracy_score, cohen_kappa_score\n\n## Logistic regression\nprint(confusion_matrix(y_test, doc_lr_pred))\nprint(f\"Accuracy: {accuracy_score(y_test, doc_lr_pred):.3f}\")\nprint(f\"Kappa: {cohen_kappa_score(y_test, doc_lr_pred):.3f}\")\nprint(f\"Balanced accuracy: {balanced_accuracy_score(y_test, doc_lr_pred):.3f}\")\n\n## Classification tree\nprint(confusion_matrix(y_test, doc_ct_pred))\nprint(f\"Accuracy: {accuracy_score(y_test, doc_ct_pred):.3f}\")\nprint(f\"Kappa: {cohen_kappa_score(y_test, doc_ct_pred):.3f}\")\nprint(f\"Balanced accuracy: {balanced_accuracy_score(y_test, doc_ct_pred):.3f}\")\n\n## SVM radial basis\nprint(confusion_matrix(y_test, doc_svm_pred))\nprint(f\"Accuracy: {accuracy_score(y_test, doc_svm_pred):.3f}\")\nprint(f\"Kappa: {cohen_kappa_score(y_test, doc_svm_pred):.3f}\")\nprint(f\"Balanced accuracy: {balanced_accuracy_score(y_test, doc_svm_pred):.3f}\")\n```\n:::\n\nDifferent results for the tree and CSV due to randomness, but even with that, SVM remains the best model in terms of accuracy.\n\n:::\n\nThe conclusion may be different from one measure to another\n\n-   Accuracy: the SVM reaches the highest accuracy\n-   Kappa: the CT is the highest.\n-   Balanced accuracy: the CT is the highest.\n-   etc.\n\nLooking at the confusion matrix, we see that the data is highly unbalanced (many more \"No\" than \"Yes\"). Therefore, measures like balanced accuracy and kappa are interesting because they take this characteristics into account. This shows that the CT is probably better than the SVM because it reaches a better balance between predicting \"Yes\" and \"No\".\n\nBy looking at the sensitivity and specificity ([!! here the positive class is \"No\"]{.underline}), we see that the best model to recover the \"No\" is the logistic regression (largest sensitivity) and the best model to recover the \"Yes\" is the classification tree (largest specificity).\n\n## Probability-based measures\n\n::: panel-tabset\n### R\nTo compute the AUC (area under the ROC curve) we can use the `caret::twoClassSummary` function. The use of this function can be tricky. Its argument should be a data frame with columns (names are fixed):\n\n-   \"obs\": the observed classes\n-   \"pred\": the predicted classes\n-   two columns with names being the levels of the classes, here \"Yes\" and \"No\", containing the predicted probabilities.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_pred_lr <- data.frame(obs=df_te$visits,\n                         Yes=Doc_lr_prob,\n                         No=1-Doc_lr_prob,\n                         pred=as.factor(Doc_lr_pred))\nhead(df_pred_lr)\n\ndf_pred_ct <- data.frame(obs=df_te$visits,\n                         Doc_ct_prob,\n                         pred=as.factor(Doc_ct_pred))\nhead(df_pred_ct)\ndf_pred_svm <- data.frame(obs=df_te$visits,\n                          Doc_svm_prob,\n                          pred=as.factor(Doc_svm_pred))\nhead(df_pred_svm)\n```\n:::\n\n\nThen we pass these objects to the function, and levels of the classes to be predicted (for the function to be able to recover them in the data frame). The function compute the AUC by default (under the name ROC_.. not very wise) as well as sensitivity and specificity (that we already have).\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntwoClassSummary(df_pred_lr, lev = levels(df_pred_lr$obs))\ntwoClassSummary(df_pred_ct, lev = levels(df_pred_lr$obs))\ntwoClassSummary(df_pred_svm, lev = levels(df_pred_lr$obs))\n```\n:::\n\n\nThis brings us another view: the logistic regression has the highest AUC. This shows that varying the prediction threshold provides a good potential of improving the specificity and the sensitivity (in fine, the balanced accuracy).\n\nNow we compute the entropy using the `mnLogLoss` function (entropy is also called *log-loss*).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmnLogLoss(df_pred_lr, lev = levels(df_pred_lr$obs))\nmnLogLoss(df_pred_ct, lev = levels(df_pred_lr$obs))\nmnLogLoss(df_pred_svm, lev = levels(df_pred_lr$obs))\n```\n:::\n\n\nHere again, the entropy selects the logistic regression as the best model, though close to classification tree and SVM.\n\n### Python\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nfrom sklearn.metrics import roc_auc_score, roc_curve\n\n## Logistic regression\nprint(f\"AUC: {roc_auc_score(y_test, doc_lr_prob):.3f}\")\n\n## Classification tree\nprint(f\"AUC: {roc_auc_score(y_test, doc_ct_prob):.3f}\")\n\n## SVM radial basis\nprint(f\"AUC: {roc_auc_score(y_test, doc_svm_prob):.3f}\")\n\n# Now we compute the entropy using the `log_loss` function (entropy is also called *log-loss*).\n\nfrom sklearn.metrics import log_loss\n\n## Logistic regression\nprint(f\"Log-loss: {log_loss(y_test, doc_lr_prob):.3f}\")\n\n## Classification tree\nprint(f\"Log-loss: {log_loss(y_test, doc_ct_prob):.3f}\")\n\n## SVM radial basis\nprint(f\"Log-loss: {log_loss(y_test, doc_svm_prob):.3f}\")\n```\n:::\n\n\n:::\n\n## ROC curve & prob threshold tuning\n\n::: panel-tabset\n### R\nTo go deeper in the analysis, we now produce the ROC curve of each model using the `roc` function of the `proc` package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(pROC)\nROC_lr <- roc(obs ~ Yes, data=df_pred_lr)\nROC_ct <- roc(obs ~ Yes, data=df_pred_ct)\nROC_svm <- roc(obs ~ Yes, data=df_pred_svm)\n\nplot(ROC_lr, print.thres=\"best\")\nplot(ROC_ct, print.thres=\"best\", add=TRUE)\nplot(ROC_svm, print.thres=\"best\", add=TRUE)\n```\n:::\n\n\nThe plotting function provides an \"optimal\" threshold that reaches the best trade-off between sensitivity and specificity (according to some criterion). We see that there is room to improve this trade-off.\n\nNow, to tune this threshold, we need to do it *on the training set* to avoid overfitting. To do this, we just repeat the previous calculations (predictions) on the training set. To simplify, we only do this on the logistic regression (note that you can try on the other models; you may find that logistic regression is the best one).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDoc_lr_prob_tr <- predict(Doc_lr, newdata=df_tr, type=\"response\")\ndf_pred_lr_tr <- data.frame(obs=df_tr$visits,\n                            Yes=Doc_lr_prob_tr)\nROC_lr_tr <- roc(obs ~ Yes, data=df_pred_lr_tr)\nplot(ROC_lr_tr, print.thres=\"best\")\n```\n:::\n\n\nThe best threshold is 0.193. Now let us compute the confusion table with this threshold.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDoc_lr_pred_opt <- ifelse(Doc_lr_prob>0.193,\"Yes\",\"No\")\nconfusionMatrix(data=as.factor(Doc_lr_pred_opt), reference = df_te$visits)\n```\n:::\n\n\nWe now have a model with an accuracy of circa $70\\%$ but with a balanced accuracy of $67\\%$. Far from perfect, this is still an interesting improvement compare to the CT $62\\%$. The specificity and sensitivity are now respectively $62\\%$ and $72\\%$. The specificity in particular made a huge improvement (from around $29\\%$ at best - by CT - to $62\\%$ - by log. reg).\n\nIf the aim is to predict both \"Yes\" and \"No\", this last model (log. reg. with tuned threshold) is the best one to use.\n\n### Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\n## Logistic regression\n## We need to turn back our results into binary values to be plotted\ndoc_lr_prob_dict = {'Yes': 1, 'No': 0}\ny_test_binary = np.array([doc_lr_prob_dict[x] for x in y_test])\nfpr_lr, tpr_lr, thresholds_lr = roc_curve(y_test_binary, doc_lr_prob)\nplt.plot(fpr_lr, tpr_lr, label=\"Logistic Regression\")\n\n## Classification tree\ndoc_ct_prob_dict = {'Yes': 1, 'No': 0}\ny_test_binary = np.array([doc_ct_prob_dict[x] for x in y_test])\nfpr_ct, tpr_ct, thresholds_ct = roc_curve(y_test_binary, doc_ct_prob)\nplt.plot(fpr_ct, tpr_ct, label=\"Classification Tree\")\n\n## SVM radial basis\ndoc_svm_prob_dict = {'Yes': 1, 'No': 0}\ny_test_binary = np.array([doc_svm_prob_dict[x] for x in y_test])\nfpr_svm, tpr_svm, thresholds_svm = roc_curve(y_test_binary, doc_svm_prob)\n\n# Clear the last plot (if any)\n# plt.clf()\n\nplt.plot(fpr_svm, tpr_svm, label=\"SVM Radial Basis\")\n# Plot the ROC curve\nplt.plot([0, 1], [0, 1], 'k--', label=\"Random Classifier\")\nplt.xlabel(\"False Positive Rate\")\nplt.ylabel(\"True Positive Rate\")\nplt.title(\"ROC Curve\")\nplt.legend()\nplt.show()\n```\n:::\n\n\nWe can then plot the results in the similar way to R:\n\n\n::: {.cell}\n\n```{.python .cell-code}\ndoc_lr_prob_tr = doc_lr.predict_proba(X_train)[:,1]\ndoc_lr_prob_tr_dict = {'Yes': 1, 'No': 0}\ny_train_binary = np.array([doc_lr_prob_tr_dict[x] for x in y_train])\nfpr_lr_tr, tpr_lr_tr, thresholds_lr_tr = roc_curve(y_train_binary, doc_lr_prob_tr)\noptimal_idx = np.argmax(tpr_lr_tr - fpr_lr_tr)\noptimal_threshold = thresholds_lr_tr[optimal_idx]\nprint(f\"Optimal threshold: {optimal_threshold:.3f}\")\n```\n:::\n\n\nFinally, we print the confusion matrix again:\n\n\n::: {.cell}\n\n```{.python .cell-code}\ndoc_lr_pred_opt = np.where(doc_lr_prob > optimal_threshold, \"Yes\", \"No\")\nprint(confusion_matrix(y_test, doc_lr_pred_opt))\n```\n:::\n\nThe logistic regression produced with R was better.\n\n:::\n\n# Your turn\n\n## Classification\n\nRepeat the analysis on the German credit data. Put several models in competition. Tune them and try to optimize their threshold. Select the best one and analyze its performance.\n\n## Regression\n\nRepeat the analysis on the nursing cost data. Put several models in competition. Tune them and select the best one. Analyze its performance using a scatterplot.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}